<!DOCTYPE html>
<html>

<head>

    <style>
        canvas {
            box-shadow: inset -1px -1px #fff, inset 1px 1px grey, inset -2px -2px #dfdfdf, inset 2px 2px #0a0a0a;
        }

        textarea {
            font-family: "Lucida Console", "DejaVu Sans Mono", monospace;
            font-weight: bold;
            resize: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-color: #fff;
            border-radius: 0;
            box-shadow: inset -1px -1px #fff, inset 1px 1px grey, inset -2px -2px #dfdfdf, inset 2px 2px #0a0a0a;
            box-sizing: border-box;
            padding: 3px 4px;
            line-height: 1.25;
            font-size: 1rem;
        }
        .nav {
            min-width: 25px;
            min-height: 25px;
        }
    </style>
</head>

<body>
    <h1>Hello World</h1>
    <p>I'm hosted with GitHub Pages.</p>
    <center>
        <div style="display: flex; justify-content: space-evenly;flex-wrap: wrap;">
            <canvas style="background-color:#eee; height: 500px; width: 500px;" id="canvas" width="500"
                height="500"></canvas>
            <div>
                <pre>Input vector (x,y,z,theta)</pre>
                <textarea id="Vvalue" rows=1 cols="30" readonly></textarea><textarea id="Tvalue" rows=1 cols="2"
                    readonly></textarea>
                <pre>Normalized vector</pre>
                <textarea id="Nvalue" rows=1 cols="35" readonly></textarea>
                <pre>Quaternion (w,x,y,z)</pre>
                <textarea id="Qvalue" rows=1 cols="35" readonly></textarea>
                <pre>Rotation matrix</pre>
                <textarea id="Mvalue" rows=3 cols="35" readonly></textarea>
                <pre>Vertices of some cube</pre>
                <textarea id="Pvalue" rows=8 cols="35" readonly></textarea>
            </div>
        </div>
        <button id="step">Pause/Resume</button>

        <div><br>
            <button class="nav" id="b1" onclick="vIn = new vector3(1, -1, 0)">|\</button>
            <button class="nav" id="b2" onclick="vIn = new vector3(1, 0, 0)">/\</button>
            <button class="nav" id="b3" onclick="vIn = new vector3(1, 1, 0)">/|</button><br>
            <button class="nav" id="b4" onclick="vIn = new vector3(0, -1, 0)">&lt;</button>
            <button class="nav" id="b5" onclick="thetaDeg = thetaDeg>0?0:0.5">&nbsp;</button>
            <button class="nav" id="b6" onclick="vIn = new vector3(0, 1, 0)">&gt;</button><br>
            <button class="nav" id="b7" onclick="vIn = new vector3(-1, -1, 0)">|/</button>
            <button class="nav" id="b8" onclick="vIn = new vector3(-1, 0, 0)">\/</button>
            <button class="nav" id="b9" onclick="vIn = new vector3(-1, 1, 0)">\|</button>
        </div>
        <div>
            <button class="nav" id="b10" onclick="vIn = new vector3(0, 0, -1)">)</button>
            <button class="nav" id="b5">&nbsp;</button>
            <button class="nav" id="b11" onclick="vIn = new vector3(0, 0, 1)">(</button>
        </div>
        <pre>Show back faces <input type="checkbox" onclick="face_culling = !face_culling"></pre>
        <pre>Sort by Z depth <input type="checkbox" onclick="z_depth = !z_depth" checked></pre>
        <pre>Opacity (0-1) <input type="range" min = "0", max="1" value="0.9" step="0.05" oninput="opacity = this.value"></pre>
    </center>
    <p id="Xvalue"></p>
    <p id="Cvalue"></p>
    <script>
        "use strict";
        var vector3 = function (x, y, z) {
            this.x = parseFloat(x);
            this.y = parseFloat(y);
            this.z = parseFloat(z);
            vector3.prototype.toString = function () {
                return `${this.x.toFixed(5).padStart(10, ' ')},${this.y.toFixed(5).padStart(10, ' ')},${this.z.toFixed(5).padStart(10, ' ')}`;
            };
            function array() {
                return [this.x, this.y, this.z];
            }
        }
        var quaternion = function (w, x, y, z) {
            this.w = parseFloat(w);
            this.x = parseFloat(x);
            this.y = parseFloat(y);
            this.z = parseFloat(z);
            quaternion.prototype.toString = function () {
                return `${w.toFixed(5).padStart(8, ' ')},${x.toFixed(5).padStart(8, ' ')},${y.toFixed(5).padStart(8, ' ')},${z.toFixed(5).padStart(8, ' ')}`;
            }
        }
        var cube = function (position, edgeLen) {
            let d = edgeLen / 2;
            this.points = [
                new vector3(position.x - d, position.y - d, position.z + d),
                new vector3(position.x + d, position.y - d, position.z + d),
                new vector3(position.x + d, position.y + d, position.z + d),
                new vector3(position.x - d, position.y + d, position.z + d),
                new vector3(position.x + d, position.y - d, position.z - d),
                new vector3(position.x + d, position.y + d, position.z - d),
                new vector3(position.x - d, position.y + d, position.z - d),
                new vector3(position.x - d, position.y - d, position.z - d)];
            this.faces = [
                [this.points[0], this.points[1], this.points[2], this.points[3]],
                [this.points[1], this.points[4], this.points[5], this.points[2]],
                [this.points[3], this.points[2], this.points[5], this.points[6]],
                [this.points[7], this.points[6], this.points[5], this.points[4]],
                [this.points[3], this.points[6], this.points[7], this.points[0]],
                [this.points[7], this.points[4], this.points[1], this.points[0]]
            ];

        }
        function faceCulling(face) {
            return (face[1].x - face[0].x) * (face[2].y - face[0].y) - (face[1].y - face[0].y) * (face[2].x - face[0].x) >= 0;
        }
        function translate(w) {
            return new vector3(w.x, w.y, 0);
        }
        function draw(object, ctx, dx, dy, c) {
            let mesh = add_z_depth(flatten(object));
            if(z_depth) mesh.sort((a, b) => a.z_avg - b.z_avg);//sort by average face z value
            for (let i = 0; i < mesh.length; i++) {
                ctx.beginPath();
                ctx.moveTo(mesh[i][0].x + dx, mesh[i][0].y + dy);
                for (let j = 1; j < mesh[i].length; j++) {
                    ctx.lineTo(mesh[i][j].x + dx, mesh[i][j].y + dy);
                }
                ctx.closePath();
                ctx.stroke();
                ctx.fill();
                //var fgfgf = `rgba(${getRndInteger(0, 255)},${getRndInteger(0, 255)},${getRndInteger(0, 255)},${getRndInteger(1, 10) / 10})`;
                //ctx.fillStyle = fgfgf;
            }
        }
        function add_z_depth(mesh) {
            mesh.forEach(face => {
                face.z_avg = (face[0].z + face[1].z + face[2].z + face[3].z) / 4;
            });
            return mesh;
        }
        function flatten(object) {
            let objectCount = object.length, faceCount, mesh = [];
            if (face_culling) {
                for (var i = 0; i < objectCount; i++) {
                    faceCount = object[i].faces.length;
                    for (var j = 0; j < faceCount; j++) {
                        if (faceCulling(object[i].faces[j])) {
                            mesh.push(object[i].faces[j]);
                        }
                    }
                }
            }
            else {
                for (var i = 0; i < objectCount; i++) {
                    faceCount = object[i].faces.length;
                    for (var j = 0; j < faceCount; j++) {
                        mesh.push(object[i].faces[j]);
                    }
                }
            }
            return mesh;
        }
        function getRndInteger(min, max) {
            return Math.floor(Math.random() * (max - min)) + min;
        }
        function RotateQ(object, AngDeg, v3) {
            const initialQ = new quaternion(1, 0, 0, 0);
            var rotationalQ = AVtoQ(AngDeg * Math.PI / 180, v3);
            Qvalue.innerHTML = rotationalQ;
            var rotationalM = RotMatrix(MultiplyQ(initialQ, rotationalQ));
            for (let i = 0; i < object.points.length; i++) {
                object.points[i] = MultiplyMV(rotationalM, object.points[i]);
            }
            Pvalue.innerHTML = FormatText(object.points);
        }
        function AVtoQ(AngRad, v3) {
            var w = Math.cos(AngRad / 2);
            var s = Math.sin(AngRad / 2);
            return new quaternion(w, v3.x * s, v3.y * s, v3.z * s);
        }
        function MultiplyMV(matrix3x3, vector3) {
            let x = vector3.x * 1, y = vector3.y * 1, z = vector3.z * 1;
            vector3.x = matrix3x3[0][0] * x + matrix3x3[0][1] * y + matrix3x3[0][2] * z;
            vector3.y = matrix3x3[1][0] * x + matrix3x3[1][1] * y + matrix3x3[1][2] * z;
            vector3.z = matrix3x3[2][0] * x + matrix3x3[2][1] * y + matrix3x3[2][2] * z;
            return vector3;
        }
        function MultiplyQ(q1, q2) {
            return new quaternion(
                (q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z),
                (q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y),
                (q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x),
                (q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w)
            );
        }
        function FormatText(v) {
            let out = "";
            for (let i = 0; i < v.length; i++) {
                if (v[i] !== Object(v[i])) {
                    out += `${v[i].toFixed(5).padStart(10, ' ')}${i >= v.length - 1 ? '' : ','}`;
                }
                else {
                    out += `${v[i].toString()}${i >= v.length - 1 ? '' : '\n'}`;
                }
            }
            return out;
        }
        function RotMatrix(q) {
            var x = [2 * (.5 - q.y * q.y - q.z * q.z), 2 * (q.x * q.y - q.w * q.z), 2 * (q.x * q.z + q.w * q.y)];
            var y = [2 * (q.x * q.y + q.w * q.z), 2 * (.5 - q.x * q.x - q.z * q.z), 2 * (q.y * q.z - q.w * q.x)];
            var z = [2 * (q.x * q.z - q.w * q.y), 2 * (q.y * q.z + q.w * q.x), 2 * (.5 - q.x * q.x - q.y * q.y)];
            Mvalue.innerHTML = `${FormatText(x)}\n${FormatText(y)}\n${FormatText(z)}`;
            return [x, y, z];
        }
        function normalize(q) {
            const ep1 = 1.001, ep2 = 0.999;
            var hasW = Object.hasOwn(q, 'w');
            var distance = q.x * q.x + q.y * q.y + q.z * q.z;
            const qN = hasW ? new quaternion() : new vector3();
            if (hasW) { distance += q.w * q.w }
            if (distance > ep1 || distance < ep2) {
                distance = Math.sqrt(distance);
                if (hasW) { qN.w = q.w / distance; }
                qN.x = q.x / distance;
                qN.y = q.y / distance;
                qN.z = q.z / distance;
            }
            else {
                if (hasW) { qN.w = q.w; }
                qN.x = q.x;
                qN.y = q.y;
                qN.z = q.z;
            }
            Nvalue.innerHTML = qN;
            return qN;
        }

        //inicjalizacja
        const Mvalue = document.getElementById("Mvalue"),
            Pvalue = document.getElementById("Pvalue"),
            Qvalue = document.getElementById("Qvalue"),
            Vvalue = document.getElementById("Vvalue"),
            Nvalue = document.getElementById("Nvalue"),
            Tvalue = document.getElementById("Tvalue"),
            stepBt = document.getElementById("step"),
            ctx = document.getElementById('canvas').getContext("2d");
        const scale = 50, dx = 250, dy = 250;
        var face_culling = true, continousAnimation = true, z_depth = true,opacity = 0.9;
        ctx.strokeStyle = '#abb';
        ctx.fillStyle = "white";
        const objects = [
            new cube(new vector3(-3 * scale, -scale, 0), scale),
            new cube(new vector3(-3 * scale, 0, 0), scale),
            new cube(new vector3(-3 * scale, scale, 0), scale),
            new cube(new vector3(-2 * scale, 2 * scale, 0), scale),
            new cube(new vector3(-1 * scale, 3 * scale, 0), scale),
            new cube(new vector3(0 * scale, 3 * scale, 0), scale),
            new cube(new vector3(1 * scale, 3 * scale, 0), scale),
            new cube(new vector3(2 * scale, 2 * scale, 0), scale),
            new cube(new vector3(3 * scale, 0, 0), scale),
            new cube(new vector3(3 * scale, scale, 0), scale),
            new cube(new vector3(3 * scale, -scale, 0), scale),
            new cube(new vector3(-2 * scale, -2 * scale, 0), scale),
            new cube(new vector3(2 * scale, -2 * scale, 0), scale),
            new cube(new vector3(-1 * scale, -3 * scale, 0), scale),
            new cube(new vector3(0 * scale, -3 * scale, 0), scale),
            new cube(new vector3(1 * scale, -3 * scale, 0), scale),
            new cube(new vector3(-1 * scale, scale, 3 * scale), scale),
            new cube(new vector3(0 * scale, scale, 3 * scale), scale),
            new cube(new vector3(scale, scale, 3 * scale), scale),
            new cube(new vector3(0, 0, 0), scale),
            new cube(new vector3(scale, -scale, -2 * scale), scale),
            new cube(new vector3(-scale, -scale, -2 * scale), scale),
        ];
        let x = 0, y = 0, c = 10, vIn = new vector3(1, 0, 1), vNm = normalize(vIn), thetaDeg = 0.5;
        stepBt.addEventListener("click", function () { continousAnimation = !continousAnimation; });
        draw(objects, ctx, dx, dy, c);
        window.onload = MainLoop
        //main
        function MainLoop() {
            if (continousAnimation) {
                Vvalue.innerHTML = vIn;
                Tvalue.innerHTML = thetaDeg;
                Nvalue.innerHTML = vNm;
                objects.forEach(element => {
                    RotateQ(element, thetaDeg, normalize(vIn));
                });
                ctx.clearRect(0, 0, 500, 500);
                ctx.fillStyle = `rgba(255,255,255, ${opacity})`;
                draw(objects, ctx, dx, dy, c);
            }
            window.requestAnimationFrame(MainLoop);
        }
    </script>

</body>

</html>